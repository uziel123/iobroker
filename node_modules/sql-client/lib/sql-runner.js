// Generated by CoffeeScript 1.10.0
(function() {
  var ObjectUtil, SQLRunner, Util, fs,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  fs = require('fs');

  Util = require('inote-util').Util;

  ObjectUtil = require('inote-util').ObjectUtil;

  SQLRunner = (function() {
    SQLRunner.prototype.stop_on_error = false;

    function SQLRunner(client, options) {
      var f, i, len, ref;
      if (client == null) {
        client = null;
      }
      if (options == null) {
        options = {};
      }
      this.main = bind(this.main, this);
      this._stringify_results = bind(this._stringify_results, this);
      this._handle_argv = bind(this._handle_argv, this);
      this._get_options = bind(this._get_options, this);
      this.execute_file = bind(this.execute_file, this);
      this.close = bind(this.close, this);
      this.set_client = bind(this.set_client, this);
      if ((client != null) && (options == null) && (client.execute == null)) {
        options = client;
        client = null;
      }
      if ((client == null) && ((options != null ? options.client : void 0) != null)) {
        client = options.client;
        options.client = null;
      }
      if (options != null) {
        ref = ['stop_on_error'];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          if (options[f]) {
            this[f] = options[f];
          }
        }
      }
      if (client != null) {
        this.set_client(client);
      }
    }

    SQLRunner.prototype.set_client = function(client) {
      return this.client = client;
    };

    SQLRunner.prototype.close = function(callback) {
      if (this.client != null) {
        return this.client.disconnect(callback);
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    SQLRunner.prototype.execute = function(sql, callback) {
      var action, error, responses, when_done;
      responses = [];
      error = null;
      if (Array.isArray(sql)) {
        action = (function(_this) {
          return function(stmt, index, list, next) {
            return _this.client.execute(stmt, function() {
              var err, tail;
              err = arguments[0], tail = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              responses.push([err].concat(tail));
              if (err != null) {
                error = err;
                if (stop_on_error) {
                  return callback(error, responses);
                } else {
                  return next();
                }
              } else {
                return next();
              }
            });
          };
        })(this);
        when_done = (function(_this) {
          return function() {
            return callback(error, responses);
          };
        })(this);
        return Util.for_each_async(sql, action, when_done);
      } else {
        return this.client.execute(sql, callback);
      }
    };

    SQLRunner.prototype.execute_file = function(file, encoding, callback) {
      var options;
      if ((callback == null) && typeof encoding === 'function') {
        callback = encoding;
        encoding = null;
      }
      options = {};
      if (encoding != null) {
        options.encoding = encoding;
      }
      return fs.readFile(file, options, (function(_this) {
        return function(err, data) {
          if (!Util.handle_error(err, callback)) {
            return execute(data.toString(), callback);
          }
        };
      })(this));
    };

    SQLRunner.prototype._BASE_OPTIONS = {
      h: {
        alias: 'help',
        boolean: true,
        describe: "Show help"
      },
      v: {
        alias: 'verbose',
        boolean: true,
        describe: "Be more chatty."
      },
      q: {
        alias: 'quiet',
        boolean: true,
        describe: "Be less chatty."
      },
      'stop-on-error': {
        alias: 'stop_on_error',
        boolean: true,
        describe: "Stop on error"
      }
    };

    SQLRunner.prototype._get_options = function(additional) {
      if (additional == null) {
        additional = {};
      }
      return ObjectUtil.merge(this._BASE_OPTIONS, additional);
    };

    SQLRunner.prototype._handle_argv = function(argv) {
      if (argv.quiet) {
        argv.v = argv.verbose = false;
      }
      return argv;
    };

    SQLRunner.prototype._stringify_results = function() {
      var results;
      results = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return JSON.stringify(results, null, 2);
    };

    SQLRunner.prototype.main = function(argv, logfn, errfn, callback) {
      var ARGF, argf, buffer, optimist, original_argv, ref, ref1;
      if ((errfn != null) && (callback == null)) {
        callback = errfn;
        errfn = null;
      }
      if ((logfn != null) && (callback == null)) {
        callback = lognf;
        logfn = null;
      }
      if (argv == null) {
        argv = process.argv;
      }
      if (logfn == null) {
        logfn = console.log;
      }
      if (errfn == null) {
        errfn = console.error;
      }
      if (callback == null) {
        callback = process.exit;
      }
      original_argv = process.argv;
      process.argv = argv;
      try {
        optimist = require('optimist');
        argv = optimist.usage('Usage: $0 ...', this._get_options()).argv;
        argv = this._handle_argv(argv);
        if (argv.help) {
          optimist.showHelp(errfn);
          return callback();
        } else {
          if (!this.client) {
            if (!argv.quiet) {
              errfn("SQLClient not configured.");
            }
            return callback(3);
          } else {
            ARGF = require('argf');
            argf = new ARGF(argv._);
            argf.on('finished', (function(_this) {
              return function() {
                var sql;
                sql = buffer.join("\n");
                if (argv.verbose) {
                  logfn("Read " + sql.length + " character(s) in " + buffer.length + " line(s).");
                }
                if (sql.length === 0) {
                  if (!argv.quiet) {
                    errfn("No input found. Cannot continue. (Try --help for help.)");
                  }
                  callback(2);
                } else {
                  if (argv.verbose) {
                    logfn("Executing.");
                  }
                }
                return _this.execute(sql, function() {
                  var err, result;
                  err = arguments[0], result = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                  if (err != null) {
                    if (!argv.quiet) {
                      if (argv.verbose) {
                        errfn("ERROR");
                      }
                      errfn("Encountered error:", err);
                      errfn("while executing SQL:\n", sql);
                    }
                    return callback(1);
                  } else {
                    if (argv.verbose) {
                      logfn("SUCCESS");
                    }
                    if (!argv.quiet) {
                      logfn(_this._stringify_results.apply(_this, result));
                    }
                    return callback();
                  }
                });
              };
            })(this));
            if (argv.verbose) {
              if (((ref = argv._) != null ? ref.length : void 0) > 0) {
                logfn("Reading from " + ((ref1 = argv._) != null ? ref1.length : void 0) + " input files.");
              } else {
                logfn("Reading from stdin.");
              }
            }
            buffer = [];
            return argf.forEach((function(_this) {
              return function(line) {
                return buffer.push(line);
              };
            })(this));
          }
        }
      } finally {
        process.argv = original_argv;
      }
    };

    return SQLRunner;

  })();

  exports.SQLRunner = SQLRunner;

}).call(this);
